## second homework - OOP

#### 1-ФАЛ
 Реализуйте класс BooleanFunction, представляющей ФАЛ в виде таблицы истинности, позволяющий вычислять значение на двоичных наборах, а также допускающий операции из базиса Жегалкина (XOR, AND).

Конструктор принимает на вход таблицу истинности — список из значений 0 и 1. В конструкторе должны быть следующие проверки. Выполняйте их строго в указанном порядке.
1. Если входной аргумент не является список, вызовите исключение TypeError("Truth table is not a list")
2. Если длина списка не является степенью двойки, вызовите исключение ValueError("Truth table length is not a power of two")
3. Если один из элементов списка не принаджелижт множеству {0, 1}, вызовите исключение ValueError("Truth table values must be either 0 or 1")

У класса должен быть метод __str__, возвращающий строковое представление функции в формате "f(x1, x2) = (0, 0, 0, 1)". Количество переменных определяется исходя из длины таблицы истинности.

У класса должен быть метод __call__, принимающий один аргумент — список значений переменых x1, x2, ..., и возвращающий значение функции на данном наборе. Для данного метода необходимы следующие проверки:
1. Если входной аргумент не является списком, вызовите TypeError("Function argument is not a list")
2. Если длина списка не равна арности функции, вызовите ValueError("Arity mismatch")
3. Если одно из значений входного списка не принадлежит множеству {0, 1}, вызовите ValueError("Variable values must be either 0 or 1")

Также перегрузите операторы + и * так, чтобы они реализовывали над двумя ФАЛ операции XOR и AND соответственно. Данные операции возвращают объекты класса BooleanFunction. Для этих операций добавьте следующие проверки:
1. Если аргумент оператора не является объектом BooleanFunction, вызовите TypeError(f"Must be BooleanFunction, not {type(other).__name__}"), где other — аргумент оператора
2. Если арности функций не совпадают, вызовите ValueError("Arity mismatch")

Данная задача тестируется путём выполнения различного кода, манипулирующего с описанным классом. Для работы этих тестов в функции main вызовите exec(sys.stdin.read()), предварительно импортировав модуль sys. 

#### 2-Это норма
 Реализуйте абстрактный класс (используя модуль abc) NormalForm, от которого наследуются классы DNF и CNF. Класс NormalForm должен содержать конструктор; метод add_clause для добавления клауз (дизъюнктов или конъюнктов); статический метод check_values, проверяющий корректность переданного словаря со значениями переменных; абстрактный метод __call__, принимающий на вход значения переменных и вычисляющий значение нормальной формы на заданном наборе, который должен быть перегружен в классах DNF и CNF.

В конструкторе NormalForm инициализируйте список клауз пустым списком. Каждая клауза является списком целых чисел — номеров переменных с положительным или отрицательным знаком. Например, число 2 кодирует переменную x2, а число -3 — отрицание переменной x3, т.е. ~x3. В методе add_clause выполните следующие проверки:
1. Если клауза на входе не является списком, вызовите TypeError("Not a list")
2. Далее, внутри цикла по списку клаузы выполните проверку, что каждый элемент списка является числом (в противном случае вызовите TypeError("Not an int")), а также, что число не равно нулю (в противном случае вызовите ValueError("Element == 0"))

В статическом методе check_values выполните следующие проверки:
1. Если переданный аргумент не является словарём, вызовите TypeError("Not a dict")
2. Если ключ словаря не является целым числом, вызовите TypeError("Not an int")
3. Если ключ словаря меньше 1, вызовите ValueError("Key < 1")
4. Если значение по ключу не является целым числом, вызовите TypeError("Not an int")
5. Если значение по ключу не принадлежит множеству {0, 1}, вызовите ValueError("Value not in {0, 1}")

Отнаследуйте классы DNF и CNF от класса NormalForm, в конструкторе вызовите конструктор базового класа. Перегрузите методы __call__ таким образом, чтобы он соответствовал вычислению ДНФ и КНФ при заданных значениях переменных. В самом начале метода __call__ вызовите проверку check_values из базового класса. Если при вычислении значений клауз некоторая переменная не найдена в словаре, вызовите исключение ValueError(f"Variable {var_num} is not found"), где var_num — номер переменной, которая не была найдена в словаре, переданном в метод __call__.

Данная задача тестируется путём выполнения различного кода, манипулирующего с описанным классом. Для работы этих тестов в функции main вызовите exec(sys.stdin.read()), предварительно импортировав модуль sys. 

#### 3-Симулятор COVID-19
 Реализуйте класс-итератор CovidSimulator, симулирующий протекание болезни COVID-19. В конструктор класса передаётся два числа: продолжительность заболевания в днях и изменение температуры в градусах (число с плавающей точкой с точностью до одного знака после запятой).

Симулятор должен работать следующим образом. В первый и последний день заболевания итератор возвращает температуру 36.6. В начале периода температура повышается каждый день на указанное количество градусов, а затем опускается до нормальной температуры. При этом температура не может превысить значение 40 градусов. Таким образом, при некоторых значениях продолжительности заболевания и изменения температуры сначала происходит увеличение температуры тела, затем она несколько дней держится, а потом опускается до нормального значения.

Кроме возвращаемой температуры класс CovidSimulator должен содержать поле current_day — текущий день болезни.

Для большего понимания, как должен работать класс CovidSimulator, смотрите примеры тестов ниже.

Данная задача тестируется путём выполнения различного кода, манипулирующего с описанным классом. Для работы этих тестов в функции main вызовите exec(sys.stdin.read()), предварительно импортировав модуль sys.


#### 4-Найди Ложкина
 Реализуйте метакласс FindLozhkin, который находит в создаваемом классе атрибут lozhkin и производит с ним некоторые манипуляции.

Если атрибут lozhkin не найден, вызовите исключение TypeError("Очень плохой класс, в нём нет Ложкина").

Если атрибут lozhkin является методом класса, примените к нему декоратор, печатающий перед выполнением данного метода строку "Так сказать".

Если атрибут lozhkin является целым числом, то оно не должно быть меньше 10^9. Если оно всё-таки меньше, присвойте этому атрибуту значение 10^9.

Если атрибут lozhkin является строкой, добавьте к ней префикс "Так сказать, ".

Во всех остальных случаях не трогайте Ложкина.

Данная задача тестируется путём выполнения различного кода, манипулирующего с описанным классом. Для работы этих тестов в функции main вызовите exec(sys.stdin.read()), предварительно импортировав модуль sys. 
